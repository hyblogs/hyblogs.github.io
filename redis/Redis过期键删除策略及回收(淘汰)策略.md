# Redis 过期键删除策略及回收(淘汰)策略



> &emsp;&emsp;我们都知道 Redis 是通过采用内存进行数据存储和数据处理，如果数据量过大则占用的内存空间自然也会变得很大。在内存空间有限的物理机上，一般会设置 Redis 的最大可用内存，即 maxmemory 参数，对应的单位是字节(byte)，当 Redis 使用内存达到阈值时，会根据配置文件中的设置选取要删除的 key 来删除，从而给新的键值留出空间。为了能合理使用物理机内存，Redis 的所有键都可以设置过期策略，Redis 的每个设置了过期时间的 key 都会被放在一个独立的字典中，用于遍历删除。

## Redis 过期键删除策略

### 主动删除与被动删除

> &emsp;&emsp;**主动删除** 指：Redis 会定期随机扫描一批设置了过期时间的 key 并进行删除处理；当已用内存超过最大内存 maxmemory 时也会触发主动清除策略；
> 
> &emsp;&emsp;**被动删除** 指：key 再被操作时，Redis 主动检查 key 是否过期，过期则删除。
> &emsp;&emsp;**优劣**：对 CPU 友好，只有 key 在被操作时删除，不浪费 CPU 时间；对内存不友好，如果同时大量 key 过期，这些 key 在被使用前不会被删除，从而造成内存资源的浪费。

### 过期删除

#### 1）定时删除

> &emsp;&emsp;在设置键的过期时间同时创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作；定时删除可以归类为主动删除策略；
> 
> &emsp;&emsp;**优点**：对内存友好，可以保证过期键被尽可能快的删除释放过期键占用的内存空间；

#### 2）惰性删除

> &emsp;&emsp;放任键过期不管，直到获取键时才采取检查键是否过期，过期的话就删除该键，不过期就返回键；惰性删除可以归类为被动删除策略；
> 
> &emsp;&emsp;**优劣**：对 CPU 友好，取键时才过期检查；对内存不友好，库中可能存在大量没被访问到的过期键，它们可能永远不会被删除；

#### 3）定期删除

> &emsp;&emsp;每隔一段时间，对库进行一次检查删除过期键。删除多少及检查多少库则由算法决定；定期删除是(定时删除及惰性删除)的一种折中，他会通过限制操作执行时长及频率来减少删除操作对 CPU 执行时间影响，而确定删除策略的时长和频率就是主要难点；定期删除也是一种主动删除策略；
> 
> &emsp;&emsp;**难点**：删除太频繁执行时长过长，定期删除就会退化成定时删除策略；删除执行过少或执行时长过短，定期删除又会和惰性删除一样；
> 
> Redis实际使用的是 **惰性删除** + **定期删除** 的配合使用。

## 回收(淘汰)策略

> **volatile-lru**：从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据进行淘汰处理；
> 
> **volatile-ttl**：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰处理；
> 
> **volatile-random**：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰处理；
> 
> **allkeys-lru**：从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰处理；
> 
> **allkeys-random**：从数据集(server.db[i].dict)中任意选择数据淘汰处理；
> 
> **no-enviction(驱逐)**：禁止驱逐数据；
> 
> &emsp;&emsp;注意这里的 6 种机制，volatile 和 allkeys 规定了是对 
> **已设置过期时间的数据集** 淘汰数据还是从 **全部数据集** 淘汰数据，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。
> 
> **使用策略规则**：
> 
> (1)如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru；
> (2)如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random。
> 
> 当内存到达阈值后，所有申请内存的操作都会报错，Redis 内存淘汰机制默认设置是 **noeviction**.
> 
> ```shell
> maxmemory-policy noeviction
> ```
